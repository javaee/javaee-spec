<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (1.8.0_144) on Wed Sep 06 08:23:28 PDT 2017 -->
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Push (Java(TM) EE 8 Specification APIs)</title>
<meta name="date" content="2017-09-06">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
<script type="text/javascript" src="../../../script.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="Push (Java(TM) EE 8 Specification APIs)";
        }
    }
    catch(err) {
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Push.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../javax/faces/push/PushContext.html" title="interface in javax.faces.push"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?javax/faces/push/Push.html" target="_top">Frames</a></li>
<li><a href="Push.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.optional.element.summary">Optional</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.element.detail">Element</a></li>
</ul>
</div>
<a name="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">javax.faces.push</div>
<h2 title="Annotation Type Push" class="title">Annotation Type Push</h2>
</div>
<div class="contentContainer">
<div class="description">
<ul class="blockList">
<li class="blockList">
<hr>
<br>
<pre><a href="../../../javax/inject/Qualifier.html" title="annotation in javax.inject">@Qualifier</a>
 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html?is-external=true" title="class or interface in java.lang.annotation">@Retention</a>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Retention.html?is-external=true#value--" title="class or interface in java.lang.annotation">value</a>=<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/RetentionPolicy.html?is-external=true#RUNTIME" title="class or interface in java.lang.annotation">RUNTIME</a>)
 <a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html?is-external=true" title="class or interface in java.lang.annotation">@Target</a>(<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/Target.html?is-external=true#value--" title="class or interface in java.lang.annotation">value</a>={<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html?is-external=true#METHOD" title="class or interface in java.lang.annotation">METHOD</a>,<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html?is-external=true#FIELD" title="class or interface in java.lang.annotation">FIELD</a>,<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/annotation/ElementType.html?is-external=true#PARAMETER" title="class or interface in java.lang.annotation">PARAMETER</a>})
public @interface <span class="memberNameLabel">Push</span></pre>
<div class="block"><p class="changed_added_2_3">
 The CDI annotation <code>&#64;</code><a href="../../../javax/faces/push/Push.html" title="annotation in javax.faces.push"><code>Push</code></a> allows you to inject a <a href="../../../javax/faces/push/PushContext.html" title="interface in javax.faces.push"><code>PushContext</code></a> associated with a given
  <code>&lt;f:websocket&gt;</code> channel in any container managed artifact in WAR.
 <pre>
 &#64;Inject &#64;Push
 private PushContext channelName;
 </pre>
 

 <h3 id="configuration"><a href="#configuration">Configuration</a></h3>
 <p>
 First enable the web socket endpoint by below boolean context parameter in <code>web.xml</code>.
 <pre>
 &lt;context-param&gt;
     &lt;param-name&gt;javax.faces.ENABLE_WEBSOCKET_ENDPOINT&lt;/param-name&gt;
     &lt;param-value&gt;true&lt;/param-value&gt;
 &lt;/context-param&gt;
 </pre>


 <h3 id="usage-client"><a href="#usage-client">Usage (client)</a></h3>
 <p>
 Declare <strong><code>&lt;f:websocket&gt;</code></strong> tag in the JSF view with at least a
 <strong><code>channel</code></strong> name and an <strong><code>onmessage</code></strong> JavaScript listener
 function. The channel name may not be an EL expression and it may only contain alphanumeric characters, hyphens,
 underscores and periods.
 <p>
 Here's an example which refers an existing JavaScript listener function.
 <pre>
 &lt;f:websocket channel="someChannel" onmessage="someWebsocketListener" /&gt;
 </pre>
 <pre>
 function someWebsocketListener(message, channel, event) {
     console.log(message);
 }
 </pre>
 <p>
 Here's an example which declares an inline JavaScript listener function.
 <pre>
 &lt;f:websocket channel="someChannel" onmessage="function(message) { console.log(message); }" /&gt;
 </pre>
 <p>
 The <code>onmessage</code> JavaScript listener function will be invoked with three arguments:
 <ul>
 <li><code>message</code>: the push message as JSON object.</li>
 <li><code>channel</code>: the channel name.</li>
 <li><code>event</code>: the raw <a href="https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent"><code>
 MessageEvent</code></a> instance.</li>
 </ul>
 <p>
 In case your server is configured to run WS container on a different TCP port than the HTTP container, then you can
 use the optional <strong><code>javax.faces.WEBSOCKET_ENDPOINT_PORT</code></strong> integer context parameter in
 <code>web.xml</code> to explicitly specify the port.
 <pre>
 &lt;context-param&gt;
     &lt;param-name&gt;javax.faces.WEBSOCKET_ENDPOINT_PORT&lt;/param-name&gt;
     &lt;param-value&gt;8000&lt;/param-value&gt;
 &lt;/context-param&gt;
 </pre>
 <p>
 When successfully connected, the web socket is by default open as long as the document is open, and it will
 auto-reconnect at increasing intervals when the connection is closed/aborted as result of e.g. a network error or
 server restart. It will not auto-reconnect when the very first connection attempt already fails. The web socket will
 be implicitly closed once the document is unloaded.


 <h3 id="usage-server"><a href="#usage-server">Usage (server)</a></h3>
 <p>
 In WAR side, you can inject <strong><a href="../../../javax/faces/push/PushContext.html" title="interface in javax.faces.push"><code>PushContext</code></a></strong> via <strong><code>&#64;</code><a href="../../../javax/faces/push/Push.html" title="annotation in javax.faces.push"><code>Push</code></a></strong>
 annotation on the given channel name in any CDI/container managed artifact such as <code>@Named</code>,
 <code>@WebServlet</code>, etc wherever you'd like to send a push message and then invoke
 <strong><a href="../../../javax/faces/push/PushContext.html#send-java.lang.Object-"><code>PushContext.send(Object)</code></a></strong> with any Java object representing the push message.
 <pre>
 &#64;Inject &#64;Push
 private PushContext someChannel;

 public void sendMessage(Object message) {
     someChannel.send(message);
 }
 </pre>
 <p>
 By default the name of the channel is taken from the name of the variable into which injection takes place. The
 channel name can be optionally specified via the <code>channel</code> attribute. The example below injects the push
 context for channel name <code>foo</code> into a variable named <code>bar</code>.
 <pre>
 &#64;Inject &#64;Push(channel="foo")
 private PushContext bar;
 </pre>
 <p>
 The message object will be encoded as JSON and be delivered as <code>message</code> argument of the
 <code>onmessage</code> JavaScript listener function associated with the <code>channel</code> name. It can be a
 plain vanilla <code>String</code>, but it can also be a collection, map and even a javabean.
 <p>
 Although web sockets support two-way communication, the <code>&lt;f:websocket&gt;</code> push is designed for one-way
 communication, from server to client. In case you intend to send some data from client to server, continue
 using JSF ajax the usual way. This has among others the advantage of maintaining the JSF view
 state, the HTTP session and, importantingly, all security constraints on business service methods.


 <h3 id="scopes-and-users"><a href="#scopes-and-users">Scopes and users</a></h3>
 <p>
 By default the web socket is <code>application</code> scoped, i.e. any view/session throughout the web application
 having the same web socket channel open will receive the same push message. The push message can be sent by all users
 and the application itself.
 <p>
 The optional <strong><code>scope</code></strong> attribute can be set to <code>session</code> to restrict the push
 messages to all views in the current user session only. The push message can only be sent by the user itself and not
 by the application.
 <pre>
 &lt;f:websocket channel="someChannel" scope="session" ... /&gt;
 </pre>
 <p>
 The <code>scope</code> attribute can also be set to <code>view</code> to restrict the push messages to the current
 view only. The push message will not show up in other views in the same session even if it's the same URL. The push
 message can only be sent by the user itself and not by the application.
 <pre>
 &lt;f:websocket channel="someChannel" scope="view" ... /&gt;
 </pre>
 <p>
 The <code>scope</code> attribute may not be an EL expression and allowed values are <code>application</code>,
 <code>session</code> and <code>view</code>, case insensitive.
 <p>
 Additionally, the optional <strong><code>user</code></strong> attribute can be set to the unique identifier of the
 logged-in user, usually the login name or the user ID. This way the push message can be targeted to a specific user
 and can also be sent by other users and the application itself. The value of the <code>user</code> attribute must at
 least implement <a href="http://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html?is-external=true" title="class or interface in java.io"><code>Serializable</code></a> and have a low memory footprint, so putting entire user entity is not
 recommended.
 <p>
 E.g. when you're using container managed authentication or a related framework/library:
 <pre>
 &lt;f:websocket channel="someChannel" user="#{request.remoteUser}" ... /&gt;
 </pre>
 <p>
 Or when you have a custom user entity around in EL as <code>#{someLoggedInUser}</code> which has an <code>id</code>
 property representing its identifier:
 <pre>
 &lt;f:websocket channel="someChannel" user="#{someLoggedInUser.id}" ... /&gt;
 </pre>
 <p>
 When the <code>user</code> attribute is specified, then the <code>scope</code> defaults to <code>session</code> and
 cannot be set to <code>application</code>.
 <p>
 In the server side, the push message can be targeted to the user specified in the <code>user</code> attribute via
 <strong><a href="../../../javax/faces/push/PushContext.html#send-java.lang.Object-S-"><code>PushContext.send(Object, Serializable)</code></a></strong>. The push message can be sent by all users and the
 application itself.
 <pre>
 &#64;Inject &#64;Push
 private PushContext someChannel;

 public void sendMessage(Object message, User recipientUser) {
     Long recipientUserId = recipientUser.getId();
     someChannel.send(message, recipientUserId);
 }
 </pre>
 <p>
 Multiple users can be targeted by passing a <a href="http://docs.oracle.com/javase/8/docs/api/java/util/Collection.html?is-external=true" title="class or interface in java.util"><code>Collection</code></a> holding user identifiers to
 <strong><a href="../../../javax/faces/push/PushContext.html#send-java.lang.Object-java.util.Collection-"><code>PushContext.send(Object, Collection)</code></a></strong>.
 <pre>
 public void sendMessage(Object message, Group recipientGroup) {
     Collection&lt;Long&gt; recipientUserIds = recipientGroup.getUserIds();
     someChannel.send(message, recipientUserIds);
 }
 </pre>


 <h3 id="connecting"><a href="#connecting">Conditionally connecting</a></h3>
 <p>
 You can use the optional <strong><code>connected</code></strong> attribute to control whether to auto-connect the web
 socket or not.
 <pre>
 &lt;f:websocket ... connected="#{bean.pushable}" /&gt;
 </pre>
 <p>
 It defaults to <code>true</code> and it's under the covers interpreted as a JavaScript instruction whether to open or
 close the web socket push connection. If the value is an EL expression and it becomes <code>false</code> during an
 ajax request, then the push connection will explicitly be closed during oncomplete of that ajax request.
 <p>
 You can also explicitly set it to <code>false</code> and manually open the push connection in client side by
 invoking <strong><code>jsf.push.open(clientId)</code></strong>, passing the component's client ID.
 <pre>
 &lt;h:commandButton ... onclick="jsf.push.open('foo')"&gt;
     &lt;f:ajax ... /&gt;
 &lt;/h:commandButton&gt;
 &lt;f:websocket id="foo" channel="bar" scope="view" ... connected="false" /&gt;
 </pre>
 <p>
 In case you intend to have an one-time push and don't expect more messages,
 you can optionally explicitly close the push connection from client side by invoking
 <strong><code>jsf.push.close(clientId)</code></strong>, passing the component's client ID. For example, in the
 <code>onmessage</code> JavaScript listener function as below:
 <pre>
 function someWebsocketListener(message) {
     // ...
     jsf.push.close('foo');
 }
 </pre>


 <h3 id="events-client"><a href="#events-client">Events (client)</a></h3>
 <p>
 The optional <strong><code>onopen</code></strong> JavaScript listener function can be used to listen on open of a web
 socket in client side. This will be invoked on the very first connection attempt, regardless of whether it will be
 successful or not. This will not be invoked when the web socket auto-reconnects a broken connection after the first
 successful connection.
 <pre>
 &lt;f:websocket ... onopen="websocketOpenListener" /&gt;
 </pre>
 <pre>
 function websocketOpenListener(channel) {
     // ...
 }
 </pre>
 <p>
 The <code>onopen</code> JavaScript listener function will be invoked with one argument:
 <ul>
 <li><code>channel</code>: the channel name, useful in case you intend to have a global listener.</li>
 </ul>
 <p>
 The optional <strong><code>onclose</code></strong> JavaScript listener function can be used to listen on (ab)normal
 close of a web socket. This will be invoked when the very first connection attempt fails, or the server has returned
 close reason code <code>1000</code> (normal closure) or <code>1008</code> (policy violated), or the maximum reconnect
 attempts has exceeded. This will not be invoked when the web socket can make an auto-reconnect attempt on a broken
 connection after the first successful connection.
 <pre>
 &lt;f:websocket ... onclose="websocketCloseListener" /&gt;
 </pre>
 <pre>
 function websocketCloseListener(code, channel, event) {
     if (code == -1) {
         // Web sockets not supported by client.
     } else if (code == 1000) {
         // Normal close (as result of expired session or view).
     } else {
         // Abnormal close reason (as result of an error).
     }
 }
 </pre>
 <p>
 The <code>onclose</code> JavaScript listener function will be invoked with three arguments:
 <ul>
 <li><code>code</code>: the close reason code as integer. If this is <code>-1</code>, then the web socket
 is simply not <a href="http://caniuse.com/websockets">supported</a> by the client. If this is <code>1000</code>,
 then it was normally closed. Else if this is not <code>1000</code>, then there may be an error. See also
 <a href="http://tools.ietf.org/html/rfc6455#section-7.4.1">RFC 6455 section 7.4.1</a> and <a href="../../../javax/websocket/CloseReason.CloseCodes.html" title="enum in javax.websocket"><code>CloseReason.CloseCodes</code></a> API for
 an elaborate list of all close codes.</li>
 <li><code>channel</code>: the channel name.</li>
 <li><code>event</code>: the raw <a href="https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent"><code>
 CloseEvent</code></a> instance.</li>
 </ul>
 <p>
 When a session or view scoped socket is automatically closed with close reason code <code>1000</code> by the server
 (and thus not manually by the client via <code>jsf.push.close(clientId)</code>), then it means that the session
 or view has expired.


 <h3 id="events-server"><a href="#events-server">Events (server)</a></h3>
 <p>
 When a web socket has been opened, a new CDI <strong><a href="../../../javax/faces/event/WebsocketEvent.html" title="class in javax.faces.event"><code>WebsocketEvent</code></a></strong> will be fired with
 <strong><code>&#64;</code><a href="../../../javax/faces/event/WebsocketEvent.Opened.html" title="annotation in javax.faces.event"><code>WebsocketEvent.Opened</code></a></strong> qualifier. When a web socket has been closed, a new CDI
 <a href="../../../javax/faces/event/WebsocketEvent.html" title="class in javax.faces.event"><code>WebsocketEvent</code></a> will be fired with <strong><code>&#64;</code><a href="../../../javax/faces/event/WebsocketEvent.Closed.html" title="annotation in javax.faces.event"><code>WebsocketEvent.Closed</code></a></strong> qualifier. They can only be
 observed and collected in an application scoped CDI bean as below.
 <pre>
 &#64;ApplicationScoped
 public class WebsocketObserver {

     public void onOpen(&#64;Observes &#64;Opened WebsocketEvent event) {
         String channel = event.getChannel(); // Returns &lt;f:websocket channel&gt;.
         Long userId = event.getUser(); // Returns &lt;f:websocket user&gt;, if any.
         // ...
     }

     public void onClose(&#64;Observes &#64;Closed WebsocketEvent event) {
         String channel = event.getChannel(); // Returns &lt;f:websocket channel&gt;.
         Long userId = event.getUser(); // Returns &lt;f:websocket user&gt;, if any.
         CloseCode code = event.getCloseCode(); // Returns close reason code.
         // ...
     }

 }
 </pre>


 <h3 id="security"><a href="#security">Security considerations</a></h3>
 <p>
 If the socket is declared in a page which is only restricted to logged-in users with a specific role, then you may
 want to add the URL of the push handshake request URL to the set of restricted URLs.
 <p>
 The push handshake request URL is composed of the URI prefix <strong><code>/javax.faces.push/</code></strong>, followed
 by channel name. So, in case of for example container managed security which has already restricted an example page
 <code>/user/foo.xhtml</code> to logged-in users with the example role <code>USER</code> on the example URL pattern
 <code>/user/*</code> in <code>web.xml</code> like below,
 <pre>
 &lt;security-constraint&gt;
     &lt;web-resource-collection&gt;
         &lt;web-resource-name&gt;Restrict access to role USER.&lt;/web-resource-name&gt;
         &lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;
     &lt;/web-resource-collection&gt;
     &lt;auth-constraint&gt;
         &lt;role-name&gt;USER&lt;/role-name&gt;
     &lt;/auth-constraint&gt;
 &lt;/security-constraint&gt;
 </pre>
 <p>
 .. and the page <code>/user/foo.xhtml</code> in turn contains a <code>&lt;f:websocket channel="foo"&gt;</code>, then you
 need to add a restriction on push handshake request URL pattern of <code>/javax.faces.push/foo</code> like below.
 <pre>
 &lt;security-constraint&gt;
     &lt;web-resource-collection&gt;
         &lt;web-resource-name&gt;Restrict access to role USER.&lt;/web-resource-name&gt;
         &lt;url-pattern&gt;/user/*&lt;/url-pattern&gt;
         &lt;url-pattern&gt;/javax.faces.push/foo&lt;/url-pattern&gt;
     &lt;/web-resource-collection&gt;
     &lt;auth-constraint&gt;
         &lt;role-name&gt;USER&lt;/role-name&gt;
     &lt;/auth-constraint&gt;
 &lt;/security-constraint&gt;
 </pre>
 <p>
 As extra security, particularly for those public channels which can't be restricted by security constraints, the
 <code>&lt;f:websocket&gt;</code> will register all so far declared channels in the current HTTP session, and any
 incoming web socket open request will be checked whether they match the so far registered channels in the current
 HTTP session. In case the channel is unknown (e.g. randomly guessed or spoofed by endusers or manually reconnected
 after the session is expired), then the web socket will immediately be closed with close reason code
 <a href="../../../javax/websocket/CloseReason.CloseCodes.html#VIOLATED_POLICY"><code>CloseReason.CloseCodes.VIOLATED_POLICY</code></a> (<code>1008</code>). Also, when the HTTP session gets destroyed, all session and
 view scoped channels which are still open will explicitly be closed from server side with close reason code
 <a href="../../../javax/websocket/CloseReason.CloseCodes.html#NORMAL_CLOSURE"><code>CloseReason.CloseCodes.NORMAL_CLOSURE</code></a> (<code>1000</code>). Only application scoped sockets remain open and are still
 reachable from server end even when the session or view associated with the page in client side is expired.
 
 
 <h3 id="ui"><a href="#ui">Ajax support</a></h3>
 <p>
 In case you'd like to perform complex UI updates depending on the received push message, then you can nest 
 <code>&lt;f:ajax&gt;</code> inside <code>&lt;f:websocket&gt;</code>. Here's an example:
 <pre>
 &lt;h:panelGroup id="foo"&gt;
     ... (some complex UI here) ...
 &lt;/h:panelGroup&gt;

 &lt;h:form&gt;
     &lt;f:websocket channel="someChannel" scope="view"&gt;
         &lt;f:ajax event="someEvent" listener="#{bean.pushed}" render=":foo" /&gt;
     &lt;/f:websocket&gt;
 &lt;/h:form&gt;
 </pre>
 <p>
 Here, the push message simply represents the ajax event name. You can use any custom event name.
 <pre>
 someChannel.send("someEvent");
 </pre>
 <p>
 An alternative is to combine <code>&lt;w:websocket&gt;</code> with <code>&lt;h:commandScript&gt;</code>. E.g.
 <pre>
 &lt;h:panelGroup id="foo"&gt;
     ... (some complex UI here) ...
 &lt;/h:panelGroup&gt;

 &lt;f:websocket channel="someChannel" scope="view" onmessage="someCommandScript" /&gt;
 &lt;h:form&gt;
     &lt;h:commandScript name="someCommandScript" action="#{bean.pushed}" render=":foo" /&gt;
 &lt;/h:form&gt;
 </pre>
 <p>
 If you pass a <code>Map&lt;String,V&gt;</code> or a JavaBean as push message object, then all entries/properties will
 transparently be available as request parameters in the command script method <code>#{bean.pushed}</code>.</div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2.3</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../../../javax/faces/push/PushContext.html" title="interface in javax.faces.push"><code>PushContext</code></a>, 
<a href="../../../javax/faces/component/UIWebsocket.html" title="class in javax.faces.component"><code>UIWebsocket</code></a>, 
<a href="../../../javax/faces/event/WebsocketEvent.html" title="class in javax.faces.event"><code>WebsocketEvent</code></a></dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== ANNOTATION TYPE OPTIONAL MEMBER SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="annotation.type.optional.element.summary">
<!--   -->
</a>
<h3>Optional Element Summary</h3>
<table class="memberSummary" border="0" cellpadding="3" cellspacing="0" summary="Optional Element Summary table, listing optional elements, and an explanation">
<caption><span>Optional Elements</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Optional Element and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a></code></td>
<td class="colLast"><code><span class="memberNameLink"><a href="../../../javax/faces/push/Push.html#channel--">channel</a></span></code>
<div class="block">(Optional) The name of the push channel.</div>
</td>
</tr>
</table>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ ANNOTATION TYPE MEMBER DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="annotation.type.element.detail">
<!--   -->
</a>
<h3>Element Detail</h3>
<a name="channel--">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>channel</h4>
<pre>public abstract&nbsp;<a href="http://docs.oracle.com/javase/8/docs/api/java/lang/String.html?is-external=true" title="class or interface in java.lang">String</a>&nbsp;channel</pre>
<div class="block">(Optional) The name of the push channel. If not specified the name of the injection target field will be used.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>The name of the push channel.</dd>
</dl>
<dl>
<dt>Default:</dt>
<dd>""</dd>
</dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a name="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="class-use/Push.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li>Prev&nbsp;Class</li>
<li><a href="../../../javax/faces/push/PushContext.html" title="interface in javax.faces.push"><span class="typeNameLink">Next&nbsp;Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?javax/faces/push/Push.html" target="_top">Frames</a></li>
<li><a href="Push.html" target="_top">No&nbsp;Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Required&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.optional.element.summary">Optional</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li><a href="#annotation.type.element.detail">Element</a></li>
</ul>
</div>
<a name="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Copyright &#169; 1996-2017,     <a href="http://www.oracle.com">Oracle</a>     and/or its affiliates. All Rights Reserved.     Use is subject to     <a href="../../../doc-files/speclicense.html" target="_top">license terms</a>.</small></p>
</body>
</html>
